$$\DeclareMathOperator{\join}{\bowtie}\DeclareMathOperator{\rank}{\text{rank}}$$
# Basics
- Queries considered in this chapter can be represented by **query graphs**
![[Query Graph.png|300]]
- **Execution plans** can be represented by **join trees**
- **Selectivity** is defined as the size of the join result, divided by the size of the Cartesian product: 
$$f_{i, j} = \frac{|R_i \join _{p_{i, j}}R_j |}{|R_i \times R_j|}$$
- The **result cardinality** is the estimated size of a two-way join result
$$|R_i \bowtie _{p_{i,j}}R_j| = f_{i, j}|R_i||R_j|$$
 - The cardinality of a **join tree** can be computed as: 
$$|T| = \begin{cases}
|R_i| \qquad & \text{if $T$ is a leaf $R_i$} \\
(\Pi_{R_i \in T_1, R_j \in T_2 }f_{i,j})|T_1||T_2| \qquad & \text{if $T= T_1 \join T_2$}
\end{cases}$$ 
- For a join tree $T$, the **cost function** $C_{out}$ is defined as: 
$$C_{out}(T) = \begin{cases}
0 \qquad & \text{if $T$ is a leaf $R_i$}\\ 
|T| + C_{out}(T_1) + C_{out}(T_2) \qquad &\text{if $T = T_2 \join T_2$}
\end{cases}$$
- For single joins, the following cost functions hold: 
$$C_{nlj}(e_1 \join e_2) = |e_1||e_2|$$
$$C_{hj}(e_1 \join e_2) = 1.2 |e_1|$$
$$C_{smj}(e_1 \join e_2) = |e_1| \log (|e_1|) + |e_2|\log(|e_2|)$$
- For sequences of join operators $s = s_1 \join ... \join s_n$, the following cost functions hold: 

$$C_{nlj}(s)= \sum_{i = 2}^n |s_1 \join ... \join s_{i -1}||s_i|$$
$$C_{hj}(s)= \sum_{i = 2}^n 1.2|s_1 \join ... \join s_{i -1}|$$
$$C_{smj}(s)= \sum_{i = 2}^n |s_1 \join ... \join s_{i -1}| \log(|s_1 \join ... \join s_{i -1}|)+ \sum_{i = 2}^n |s_i|\log (|s_i|)$$
- A cost function  $C_{impl}$ is called **symmetric** if:
$$C_{impl}(e_1\join^{impl}e_2) = C_{impl}(e_2\join^{impl}e_1)$$

# Search Space
- In the search space we distinguish between 4 different dimensions: 
	1. **Query Graph Class**: chain, cycle, star, clique
	2. **Join Tree Structure**: left-deep, zig-zag, bushy
	3. **Join Construction**: With or without cross products
	4. **Cost function**: With or without ASI Property
- The number of binary trees with $n$ leaf-nodes is given by: 
$$0$$

$$\mathcal C(n) = \frac {1}{n+1}\binom{2n}{n}$$
- For $n$ relations, the number of join trees with the cross product is: 
	- **Left Deep**: $n!$ 
	- **Right Deep**: $n!$
	- **Zig-zag**: $n! 2^{n -2}$
	- **Bushy**: $n!\mathcal C(n-1)$ or $\frac{(2n-2)!}{(n-1)!}$
# Greedy Heuristics
- Greedy heuristics are fast 
- In the following, $S$ will refer to the current join sequence/intermediate result
## Left-Deep Tree Algorithms
- The following algortihms works for left-deep trees without cross products 
### Algorithm 1
- The next relation $R_i$ is chosen that minimizes a fixed weight function $w(R_i)$
- The disadvantages are, that the algorithm doesn't consider $S$ and the weight function is fixed
### Algorithm 2
- The next relation $R_i$ is chosen to minimize a **relative weight function** $w(R_i, S)$
- A disadvantage is, that the selection of the first relation has a large effect, but there is only little initial information available for it
### Algorithm 3
- The algorithm repeats algorithm 2 for each relation as a starting relation
- The final output $S'$ is the sequence yielding the minumum overall cost
## Greedy Operator Ordering
- **Greedy operating ordering** can construct more flexible **bushy trees**
- Join-trees are combined **bottom-up**
- In each step, the pair of current join trees $(T_i, T_j)$ is chosen that results in the **minimal intermediate result cardinality** $|T_i \join T_j|$ when joined
- The chosen pair is replaced by the larger join tree $T_i \join T_j$
# IKKBZ
- IKKBZ is a **polynomial algorithm** for join ordering
- It produces optimal left-deep trees without cross products
- It requires acyclic join graphs, a cost function with ASI property and a fixed join method
- The algorithm focuses on cost functions of the form: 
$$\mathcal C(T_j \join R_i) = |T_j| \cdot h_j(|R_j|)$$
- Where...
	- ...$|T_j|$ is the cardinality of the prefix result
	- ...$h_j(|R_j|)$ is the cost per input tuple of joining with $R_j$
## Algorithm
- The algorithm considers each relation as first relation to be joined, and orders the other relations by rank
- **Compounds** are constructed if the ordering constructs guarantees
## Precedence Graphs
- Given a query graph $G=(V, E)$ starting relation $R_h$, a **directed precedence graph** $G_k^P=(V_k^P, E_k^P)$  is constructed like so: 
	1. Choose $R_k$ as the root  of $G_k^P$, meaning $V_k^P=\{R_k\}$
	2. while $|V_k^P | < |V|, choose a $R_i \in V \setminus V_k^P$ such that $\exists R_j \in V_k^P: (R_j, R_i) \in E$ and add $R_i$ to $V_k^P$ and $R_j \to R_i$ to $E_k^P$
- In the following example, a precedence graph is built from a query graph, where $R_1$ is the root
![[Precedemce Graph.png|300]]
## Selectivities
- For a given precedence graph, let $R_i$ be a relation and $\mathcal R_i$ be the set of relations from which there exists a path to $R_i$, the selectivity is: 
$$s_i = \begin{cases}
1 \qquad & \text{if $|R_i| = 0$}\\
\Pi_{R_j \in \mathcal R_i }f_{i,j} \qquad & \text{if $|R_i| > 0$}
\end{cases}$$
## ASI Property
- Let $A, B$ be two sequences and let $V, U$ be two non-empty sequences
- A cost function $C$ has the ASI property, iff there exists a function $T$ and rank function defined as:
$$\text{rank}(S) = \frac{T(S)-1}{C(S)}$$
- Such that the following holds, if AUVB and AVUB satisfy precedence constraints
$$C(AUVB) \le C(AVUB) \Leftrightarrow \text{rank}(U) \le \text{rank}(V)$$
- $C_h$ has the ASI property
## Modules
- A set of sequences of nodes $M= \{A_1,...,A_n\}$ is called a module if for all sequences $B$ that do not overlap with the sequences in $M$, one of the following conditions holds: 
	- $B \to A_i \forall A_i \in M$
	- $A_i \to B, \forall A_i \in M$
	- $B \not \to A_i$ and $A_i \not \to B, \forall A_i \in M$
- For any cost function $C$ satisfying ASI, and a module $\{A, B\}$, if $A \to B$ and $\text{rank}(B) \le \text{rank}(A)$ then we find an optimal sequence among those, in which $B$ directly follows $A$
## Compound Relations and Contradictory Sequences
- If $A \to B$ but $\rank(B) \le \rank(A)$, $A$ and $B$ are **contradictory sequences**
- We combine the nodes into a new single node replacing $A$ and $B$
- The new node represents a **compound relation** comprising all relations in $A$ and $B$
- Its cardinality is computed by multiplying the cardinalities of all relations in $A$ and $B$
- Its selectivity is the product of all selectivities $s_i$ of relations contained in $A$ and $B$
- The process of building compount relations until there are no contradictory sequences is called **normalization**
- Relpacing compound relations by the sequence of relations it was derived from is called **denormalization**
- 

