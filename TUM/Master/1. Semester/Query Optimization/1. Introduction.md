# Motivation
- SQL is declarative, so a query does not specify the exact computation
- Different queries can can result in the same tuples - there are alternatives for a query
- The alternatives often have different characteristics
# Query Processing
- Queries are compiled and optimized by the compile time system, resulting in an execution plan
- The runtime system executes the plan and outputs the result
## Compile Time System
- The compile time system produces the execution plan in 7 steps: 
<div style="text-align:center;">
  <img src="compiletimesystem.png" style="transform: rotate(90deg); width:200px; height:auto;">
</div>
### Parsing
- Queries are parsed from text into **abstract syntax trees**
![[astBeforeProcessing.png|400]]
### Semantic Analysis
- The representation is normalized 
- Common expressions are factorized and constant expressions are folded
![[normalizedAST.png|400]]
### Rewrite I 
- Then, views are resolved, nested expressions are unnested and other optimizations are conducted
![[optimizedAST.png|400]]
### Plan Generation
- The best execution strategy is found and a physical plan is constructed
![[physicalPlan.png|200]]
### Rewrite
- The plan is polished
![[optimizedPhysicalPlan.png|200]]
### Code Generation
- The executable plan is generated
# Optimization Targets
- Optimization can be done according to different metrics: 
	- Minimizing response time
	- Minimize resource consumption
	- Minimize time to the first tuple
	- Maximize throughput
- During optimization, a cost function is defined expressing the goal
- A common choice is minimizing response time within given ressource limits
## Algebraic Optimization
- In general, the amount of possible expressions is large and testing for equivalence of two expressions is difficult 
- Query optimizers only search for the optimal solution in a small subset of existing equivalent queries 
- There are **constructive** and **transformative** optimization approaches
- Transformative appoaches are simpler but it is hard to find the optimal solution
![[constructiveTransformative.png|200]]
# Query Execution
- Queries are executed through the use of a **physical algebra**
- There are different operators performing specialized operations
- Each operator consumes and produces data tuple streams  
## Relational Algebra
- For real queries, relational algebra needs certain extensions: 
### Extensions
#### Map
- Every tuple $x$ in a relation $e$, $f(x)$ is computed and added as a new attribute $a$
- Output: original fields and $a$ $$\chi_{a:f}(e) = \{x \circ (a : f(x))\mid x \in e\}$$
- Example: 

| pid | name     | price |
| --- | -------- | ----- |
| 1   | pen      | 2.00  |
| 2   | notebook | 5.00  |
```SQL
SELECT *, price * 0.9 AS discount FROM products; 
```

| pid | name     | price | discount |
| --- | -------- | ----- | -------- |
| 1   | pen      | 2.00  | 1.80     |
| 2   | notebook | 5.00  | 4.50     |

#### Group By/Aggregation
- Tuples of $e$ are grouped by the attributes in $A$. For each group, aggregate by $f$ is computed and the result is stored in the attribute $a$
- Output: one tuple per group with the $A$ fields and $a$
$$\Gamma_{A; a:f}(e) = \{x \circ (a : f(y)) \mid x \in \Pi_A(e) \land y = \{z \mid z \in e \land \forall a \in A: x.a = z.a\}\}$$

| order_id | city   | amount |
| -------- | ------ | ------ |
| 1        | Vienna | 10     |
| 2        | Munich | 20     |
| 3        | Vienna | 7      |
```SQL
SELECT city, SUM(amount) AS total FROM Sales GROUP BY city;

```

| city | total |
| ---- | ----- |
| SF   | 17    |
| NY   | 20    |
####  Dependent Join
- For each tuple $x \in e_1$, we evaluate $e_2(x)$, then pair $x$ with every tuple in $e_2(x)$
- Output: Tuples combined from both relations, keep only ones that match $p$
$$e_1 ⧑_p e_2 = \{x \circ y \mid x \in e_1 \land y \in e_2(x) \land p(x \circ y)\}$$

| uid | city   | max_price |
| --- | ------ | --------- |
| 10  | Munich | 180       |
| 11  | Vienna | 250       |

| hid | city   | max_price |
| --- | ------ | --------- |
| 7   | Munich | 150       |
| 8   | Munich | 220       |
| 9   | Vienna | 240       |
```SQL
SELECT u.*, h.hid, h.price
FROM Users u
CROSS JOIN LATERAL (
  SELECT * FROM Hotels h
  WHERE h.city = u.city
) h
WHERE h.price <= u.max_price;
```

| uid | city   | max_price | hid | price |
| --- | ------ | --------- | --- | ----- |
| 10  | Munich | 180       | 7   | 150   |
| 11  | Vienna | 250       | 9   | 240   |
### Discussion
- Relational algebra does not imply an implementation
- More detailed operators exist for that effect: 
#### General Operators
- **sort** sorts the input stream according to a criteria
- **temp** materializes the input stream to make further reads cheap
- **ship** sends the input stream to a different host (distributed databases)
#### Joins
- **Nested Loop Join** $e_1⋈^{NL}e_2$: 
	- For each tuple of $e_1$, all tuples of $e_2$ are read
	- Slow, but supports all predicates
- **Blockwise Nested Loop Join** $e_1⋈^{BNL}e_2$: 
	- Chunks of $e_1$ are read into memory and $e_2$ is read once for each chunk
	- Faster but requires memory
	- For equi-joins this can further be  optimized with hashing
- **Sort Merge Join** $e_1⋈^{SM}e_2$: 
	- $e_1$ and $e_2$ are only scanned once
	- The input must be suitable and sorted
- **Hybrid-Hash Join** $e_1⋈^{HH}e_2$: 
	- $e_1$ and $e_2$ are only scanned once
	- The input must be suitable and sorted
	- Only works for equi joins
#### Other Operators
- **Aggregation Sorted Input** $\Gamma^{SI}$: 
	- Input is aggregated directly
	- Trivial and fast 
	- Requires sorted input
- **Aggregation Quick Sort** $\Gamma ^{QS}$: 
	- Sorts chunks of inputs with quick sort
	- merges chunks
- **Aggregation Heap Sort** $\Gamma^{HS}$: 
	- Similar to $\Gamma^{QS}$
	- Slower sort, longer runs
- **Aggregation Hybrid Hash** $\Gamma^{HH}$
	- Partitions like a hyrid hash join
	