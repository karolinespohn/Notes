# Motivation
- For query optimization, it is important to guarantee the optimized query is equivalent to the original query 
- For that, a formal model is needed
# Definitions
- A **tuple** is a mapping from attribute names to values in a domain
$$[\text{name : "Plato", age: 70}]$$
- A **schema** is a set of attributes and their domain, denoted as $\mathcal A(t)$
$$\{(\text{name, string), (age, number)}\}$$
## Concatenation
- The **concatenation** of two tuples $t_1, t_2$ and it is denoted with $\circ$
$$[\text{name : "Plato", age: 70}] \circ [\text{country: "Greece"}] = [\text{name : "Plato", age: 70, country: "Greece"}]$$
- For $t_1$ and $t_2$ to be concatenable, $\mathcal A(t_1) \cap \mathcal A(t_2) = \emptyset$ and thereby  $t_1 \circ t_2 = \mathcal A(t_1) \cup \mathcal A(t_2)$
## Tuple Projection 
- Through **projection**, values assigned to certain attributes can be extracted
- Selecting a single attribute $a$ from a tuple $t$ is denoted as $t.a$ and the projection produces a **value**
- Selecting multiple $A$ from a tuple $t$ is denoted as $t_{\mid A}$ and the projection produces a **tuple**
- It is required thta $a \in \mathcal A(t)$ and $A \subseteq \mathcal A(t)$
- It holds that $\mathcal A(t_{\mid A}) = A$
## Relations
- A **relation** is a set of tuples with the same schema
## Sets and Bags
- Real data is usually a **multi-set**, referred to as a **bag**
- Optimizers must consider 3 different semantics: 
	- **Logical Algebra** operates on **bags**
	- **Physical Algebra** operates on **streams**
	- **Explicit Duplicate Elimination** operates on **sets**
### Set Operations 
- The operation union ($L \cup R$), intersection ($L \cap R$) and difference ($L \setminus R$) exist with the usual semantics, 
- **Schema constraints** hold: 
	- $\mathcal A (L) = \mathcal A(R)$
	- $\mathcal A (L \cup R) = \mathcal A (L) = \mathcal A (R) = \mathcal A (L \cap R)$
	- $\mathcal A(L \setminus R) = \mathcal A(L) = \mathcal A(R)$
- For **bags**, the operations work with frequencies 
	- $\cup \to +$
	- $\cap \to \min$
	- $\setminus \to -$
## Free Variables
- Consider the predicate `age = 62`
- Age must have a meaning in the scope and be bound to the concrete value for this to be evaluable and it is a **free variable**
- For predicates, algebraic expressions and dependent joins, free variables are important 
## Selection
 - Notated as $\sigma_p(R)$, all tuples fulfilling $p$ are selected
$$\sigma_{a \ge 2} (\{[a: 1], [a:2], [a:3]\}) = \{[a:2], [a:3]\}$$
- Although predicates can be arbitrarily complex, optimizers mainly care about predicates of the form `attr=attr` and `attr = const`
- It must hold that $\mathcal F(p) = \mathcal A(R)$ and $\mathcal A(\sigma_p(R)) = \mathcal A(R)$
## Projection
- Projection $\Pi_A(R)$ samples columns from a relation
$$\Pi\{a\} (\{[a : 1, b : 1], [a : 2, b : 1]\}) = \{[a : 1], [a : 2]\}$$
- Usually, it is shortened as $\Pi_{a, b}$ instead of $\Pi_{\{a, b\}}$
- For set semantics, duplicates are removed, while for bag semantics they are kept
- It must hold that $A \subseteq \mathcal A(R)$ and $\mathcal A(\Pi_A(R)) = A$
## Rename
- Rename is denoted as $\rho_{a\to b}(R)$ and it must hold that $a \in \mathcal A(R), b \not \in \mathcal A(R)$
- It holds that $\mathcal(\rho_{a \to b}(R)) = \mathcal A(R)\setminus \{a\} \cup \{b\}$
## Join
- **Cross product** $L\times R$ pairs all tuples from $L$ with all tuples from $R$
- **Join** $L\bowtie_pR$ additionally filters the tuples according to a predicate: 
$$\sigma_p(L \times R)$$
- It must hold that $\mathcal A(L) \cap \mathcal A(R) = \emptyset$
- It also holds that $\mathcal A(L \times R) = \mathcal A(L) \times \mathcal A(R)$
## Equivalences 
### Selection and Projection
 ![[projectionSelectionEquivalences.png|400]]
### Joins
![[joinEquivalences.png|400]]
# Canonical Query Translation
- The following kind of queries will be considered: 
```SQL
SELECT DISTINCT a1, ..., an
FROM R1, ..., Rk
WHERE p
```
- Restrictions: 
	- Only select distinct (sets not bags)
	- No group by, order by, ...
	- Select clause doesn't  contain computed values but only attributes
	- no nested queries, views or NULL values
## Step 1: From Clause
- Let $R_1, ..., R_k$ be the relations in the from clause
- We construct: 
$$
F = \begin{cases}
R_1 \quad \text{if } k =1 \\
((...(R_1 \times R_2)\times ...)\times R_k) \quad \text{else}
\end{cases}
$$
## Step 2: When Clause
- Let $p$ be the predicate of the where query
- The following expression is constructed: 
$$W = \begin{cases}
F \quad \text{if there is no WHERE clause}\\
\sigma_p(F) \quad \text{else}
\\
\end{cases}$$
## Step 3: Select Clause
- The projection in the select clause is $a_1,...,a_n$ or $*$
- The following expression is constructed: 
$$
S = \begin{cases}
W \quad \text{if the projection is *}\\
\Pi_{a_1, ..., a_n} \quad \text{otherwise}
\end{cases}
$$
- $S$ is the canonical translation of the query
## Extension: Group By
- The group by clause can be added for the attributes $g_1, ...g_m$ and the aggregations $agg$ in the select query by replacing step 3 with this expression: 
$$G = \begin{cases}
W \quad \text{if there is no group by clause}\\
\Gamma_{g_1,...,g_,=,:agg(W)}  \quad \text{else}
\end{cases}$$
# Logical Query Optimization
- Logical query optimization has 3 phases: 
	1. Translate the query into its canonical algebraic expression
	2. Perform logical query optimization
	3. Perform physical query optimization
- It is built on **algebraic equivalences**: 
	- There is a set of algebraic equivalences defininf the **potential search space**
	- Rhese equivalences are used to derive new equivalent algebraic expressions
## Performing Logical Query Optimization
- Different plans for a query can only be compared compared according to **cost function**
- These functions are not available when considering the logical algebra, meaning optimization remains a **heuristic**
- Most algorithms ...
	- ...organize equivalences into groups
	- ... direct equivalences
- Directing equivalences refers to specifying a preferred side and directed equivalences are called a **rewrite rule**
- Logical query optimization follows the following phases: 
	1. Break up **conjunctive selection predicates** according to equivalence 1 ($\rightarrow$)
	2. Selections are **pushed down** according to equivalences 2 ($\rightarrow$) and 14 ($\rightarrow$)
	3. **Joins** are introduced according to equivalence 13 ($\rightarrow$)
	4. **Join Order** is determined according to equivalence 9, 10, 11 and 12
		- Different join orders can differ drastically
		- Finding an optimal plan is NP hard
	5. **Push Down Projections** are introduced according to equivalence 3 ($\leftarrow$), 4 ($\leftarrow$) and 16 ($\rightarrow$)
		- This eliminates redundant attributes
- The phases are **interdependent**, for instance different join orders can allow for a different amount of selection push-down
# Physical Query Optimization
- Physical query optimization involves refining the logical plan by incorporating **execution-specific details**
## Access Paths Selection
- Access paths selection determines how data is read from the underlying storage
- Scan and selection can be performed via index lookup or table scanned
- A rule of thumb is that if the selection returns more than $10\%$, table scans are bettern than an index scan 
## Operator Selection
- During operator selection, **logical operators** (e.g. $\bowtie$) are replaced with physical one (e.g $\bowtie^{HH}$)
- Most join operators require **equi-conditions**
- Usually, the order of how good each type of join is looks liks so: 
$$\bowtie^{NL} \; <\; \bowtie^{BNL}\; < \;\bowtie^{SM}\; < \;\bowtie^{HH}$$
- However, the actual decision of which join is best should be cost based, sometimes even $\bowtie^{NL}$ can be optimal
- Operator selection must be done for each operator
## Property Enforcer
- Certain physical operators need certain **properties**, for instance, examples must be sorted for $\bowtie^{SM}$
- Requirements include properties like sorting or hashing and they must be guaranteed as needed
## Materializing
- Materializing refers to **temporarily storing** the input or intermediate result of an operator on disk
- This is essential for **multiple consumers**, $\bowtie^{NL}$ 
- Through this, the first pass may be expensive but further passes can be cheap
