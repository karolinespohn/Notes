- Der Umgang mit Ein- und Ausgabe ist eine der Zentralen Aufgaben eines Betriebssystems
# Arten von Geraeten
- Man unterscheidet zwischen Block- und Zeichenorientierten Geraeten
## Blockorientierte Geraete
- Daten auf blockorientierten Geraeten sind in Bloecken fester Groesse gespeichert 
- Random Access ist auf jeden Block moeglich
 - Beispiele sind Blu-Rays, Festplatten und SSDs
## Zeichenorientierte Geraete
- Inhalte sind nicht adressierbar
- Zeichenorientierte Geraete senden und Empfangen Zeichenstroeme
- Beispiele sind Maus, Tastatur und Drucker
## Andere Geraete
- Manche Geraete, wie die Uhr, lassen sich in keine der Kategorien ordnen
# Struktur eines E/A-Systems
![[Aufbau EA System.png|400]]
- Grob sieht ein E/A-System aus wie oben dargestellt
- Der Controller ist Teil der Hardware
- Der Interrupt-Handler ist verantwortlich fuer die Geraete-Rueckmeldungen
- Der Geraetetreiber greift durch Controller auf das Geraet zu und fuehrt dessen Software aus
- Bei der geraeteunabhaengigen Software geht es beispielsweise um das puffern von Daten oder belegen eines Geraets
- Die User-Level-Software ist beispielsweise verantwortlich fuer Ein- und Ausgabe sowie Spooling
# Controller
- I/O Geraete besitzen einen Controller, der eine Hardware Schnittstelle zum Programm besitzt
- Durch den Controller kann man einen Bitstrom an das Geraet schicken bzw. vom Geraet empfangen
- Ein Controller besitzt Register, beispielsweise um Informationen vom Betriebssystem zu empfangen oder Statusmeldungen mitzuteilen
![[IO Controller Register.png|300]]
## Interaktion mit dem Controller
- Es gibt verschiedene Moeglichkeiten um mit einem Controller zu kommunizieren
### I/O Ports
- Ein Teil des Hauptspeichers wird als I/O Bereich verwendet
- Mittels speziellen IO-Kommandos wie `IN`, `OUT` schreibt man Informationen in die IO-Adressen
### Memory Mapped IO
- Man weisst jedem Controller Register Adressen im Speicher zu 
- Um auf diese Adressen zu schreiben benoetigt man keine speziellen IO-Kommandos
## Datenaustausch mit dem Controller
### Programmed IO
- Der naive Weg waere, dass die CPU sich um alles kuemmert, und blockiert, bis die Ein- /Ausgabe fertig ist
### Interrupts
- Eine asynchrone Alternative ist, dass der Controller Interrupts signalisiert, wenn es fertig ist
- Der auf IO wartende Prozess wird erst auf rechenwillig gesetzt, wenn der Interrupt aufgetreten ist
### Direct Memory Access
- Die Uebertragung von Daten aus den IO-Registern ist sehr teuer
- Deshalb gibt man DMA-Controllern Zugriff auf den Speicher unabhaengig von der CPU
- Der DMA-Controller wird vom Betriebssystem konfiguriert und ist eigenstaendig in der Lage, Daten eines IO-Geraets entgegenzunehmen
- Die CPU muss dabei nur die anfaengliche Konfiguration des DMA-Controller ausfuehren, nicht das Kopieren der Daten
![[Direct Memory Access.png|300]]
## Puffern von Daten
- Daten aus IO-Geraeten werden zunaechst gepuffert, bevor sie weiterverarbeitet werden
### Einlesen von Daten ohne Puffer
- Ohne Puffer koennen Daten mittels des `read` Syscalls eingelesen werden
- Der lesende Prozess muesste dann jedoch bis zur uebertragung eines Zeichens blockieren, und dann einen Interrupt ausloesen
- Dies muesste fuer jedes Zeichen ausgefuehrt werden, wodurch die Anzahl an Inerrupts massiv steigen wuerde
### Einfache Puffer und Doppelte Puffer
- Bei einfachen Puffern stellt der Nutzerprozess einen Puffer im Speicher bereit, und entleert ihn, wenn er voll ist
- Bei doppelten Puffern wird ein Puffer geleert waehrend der andere befuellt wird
- Die Entleerung muss bei beiden Varianten schnell sein, damit das E/A-Geraet weiterhin freien Speicher hat
### Zirkulaere Puffer (Ringbuffer)
- Ringbuffer aehneln doppelten Puffern
- Es gibt aber nicht 2 Puffer, sondern das Geraet schreibt auf einer Seite rein, waehrend der Prozess aus der anderen Seite liest
# Geraete-Treiber
- Geraete-Treiber sind Software-Module mit Kenntnissen des Befehlssatzes des zugehoerigen Geraets
- Ueber Geraetetreiber kann man mit Hardware Interagieren
- Sie stellen dabei sowohl Geraete-spezifische Funktionen, als auch geteilte Kommandos zur Verfuegung
![[Geraete Treiber.png|300]]
## Aufgaben
- Geraetetreiber sind fuer die Definition und Aktivierung des Geraetes verantwortlich, sowie die initialisierung des Controllers
- E/A-Anforderungen werden durch den Treiber in den Befehlssatz des Geraetes uebersetzt
- Weiters antwortet er auf Hardwaresignale des Geraetes oder Controllers und meldet Fehler von Geraet oder Controller
- Auch fuer die Uebertragung von Daten und Zustandsinfos vom und zum Geraet, sowie das Puffern von Ein- und Ausgabe ist der Treiber verantwortlich 
## Interaktion von Treiber und Controller
- Der Treiber steht zwischen dem E/A-System und dem Controller
- Er schickt Kommandos an den Controller und blockiert, bis der Controller das Ende signalisiert und der Treiber vom Interrupt-Handler entsperrt wird
- Der Treiber verarbeitet die empfangenen Daten beziehungsweise schickt neue Daten
# Geraete-unabhaengige Software
- Durch Geraete-unabhaengige Software wird die Treiber-Programmierung und die Einbindung neuer Software einfach
## Aufgaben
### Einheitliche Schnittstellen
- Einheitliche Schnittstellen zwischen Geraetetreibern und dem restlichen Betriebssystem sollen vereinfacht bereitgestellt werden
- Die Menge an Funktionen muss gleich bleiben, und die Benennung von Geraeten, sowie der Umgang mit Dateitypen und Pufferung einheitlich  
![[Einheitliche Schnittstellen.png|300]]
### Puffern und Fehlerbehandlung
- Sofern nicht im Treiber geschehen beziehungsweise zusaetzlich zum Treiber muss gepuffert werden und Fehlerbehandlung Betrieben werden
### Festlegung von Parametern
- Geraeteunabhaengige Parameter wie Blockgroesse werden gesetzt
# Spooling
- Simultaneous Peripherial Operations Online
- Spooling ist notwendig, wenn Geraete exklusiv nutzbar sind
- Gibt es mehrere Anfragen werden sie durch den Spooler verwaltet
![[Spooler.png|400]]
# Festplatten
- Festplatten sind Blockgeraete, bestehend aus uebereinandergestapelten Platten
![[Cylinder, Platters.png|400]]
- Fie Platten sind beidseitig beschreibbar und auf den Platten gibt es konzentrische Tracks
![[Platter.png|280]]
- Tracks werden dann wieder in gleichgrosse Sektoren geteilt
![[Track.png|200]]
- Die Platten drehen sich jeweils
## Sektoren
- Sektoren sind aufgebaut wiefolgt: 
![[Sektor.png]]
- In der Praeambel stehen Synchronisations-Bits sowie Track- und Sektornummer
- Typischerweise folgen dann 512 Byte Daten
- Zuletzt befinden sich Error Correcting Codes
- Der Schreib- /Lesekopf bewegt sich jeweils nach vor und nach hinten
- Haeufig lesen Controller ganze Tracks
- Sowohl das Lesen ueber Sektorengrenzen als auch das Umschalten zwischen Schreib und Lesekopf benoetigt Zeit