# Von Neumann
![[von Neumann.png|400]]
- In der von-Neumann Architektur ist die CPU durch das Bussystem mit dem Ein-/Ausgabewerk und dem Speicherwerk verbunden
- Das Bussystem bildet jedoch einen Flaschenhals, weshalb Zugriffe auf den Hauptspeicher teuer sind
- Um den von-Neumann Flaschenhals zu reduzieren, implementieren Betriebssysteme Speicherhierarchien
![[Speicherhierarchie.png|400]]
# Adressraeume
- In gewissen Systemen haben alle Programme vollen Zugriff auf den gesamten physischen Speicher
- Dadurch koennen aber einzelne Prozesse den gesamten Hauptspeicher belegen, oder dem Betriebssystem oder anderen Prozessen im Weg stehen
- Fuer gewoehnlich abstrahiert man deshalb den physischen Adressraum, sodass jeder Prozess einen eigenen, isolierten Prozessraum erhaelt
- Mit einer Abbildung werden virtuelle Speicheradressen auf physische abgebildet
## Diskrete Adressierung
- Bei der diskreten Adressierung entsprichrt die virtuelle Adresse der physischen Adresse
### Extensives Swapping
- Bei einer Umsetzung mittels exzesiven Swappings ist stets nur ein Programm im Speicher
- Will man ein anderes Programm ausfuehren, muss das alte Programm auf die Festplatte geladen werden und das neue von der Festplatte geholt werden
### Relokation
- Bei der Relokation werden die Adressen in Programmen umgeschrieben, sodass sie den richtigen Adressen im physischem Speicher entsprechen
- Dabei hat aber noch immer jedes Programm Zugriff auf den gesamten Hauptspeicher und kann somit andere Programme stoeren
## Basisadressierung
- Fuer jeden virtuellen Adressraum wird eine Basisadresse $b_x$ festgelegt
- Die physische Adresse berechnet sich durch die Addition der virtuellen Adresse und der Basisadresse
## Segmentaddressierung
- Bei der Segmentadressierung wird der Adressraum in logische Segmente, beispielsweise fuer Code, Stack und Daten unterteilt
- Fuer jedes Segment braucht man die Startadresse als Basisadresse und die Laenge des Segments
- Beispielsweise koennen die Segmente in einer Tabelle mit Basisadresse, Laenge und Flags gehandhabt werden
![[Segmentadressierung.png|400]]
- Ist der Speicher voll, werden Prozesse temporaer auf die Festplatte gelagert
# Datenstrukturen fuer die Speicherverwaltung
## Bitmap
- Der Speicher wird in Bloecke gleicher Bloecke geteilt
- Mittles einer Bitmap wird der Speicher indexiert, wobei ein bit einem Block entspricht
- Ist der Block besetzt, so wird das bit auf $1$ gesetzt, sonst auf $0$
![[Bitmap.png|400]]
- Werden die Bloecke zu gross gewaehlt, kann es zu einer Verschwendung von Speicherplatz kommen
- Werden die Bloecke zu klein gewaehlt, so ist die Bitmap zu gross
- Bitmaps erlauben einfachen Zugriff, aber die Suche nach freiem Speicher ist aufwendig
## Verkettete Listen
- Alternativ kann man eine verkettete Liste verwenden
- Fuer jeden Bereich im Speicher wird jeweils die Startadresse, Laenge und Belegung gespeichert
![[Verkettete Liste.png|400]]
- Die Speicheraufteilung ist dadurch flexibel, das finden von freiem Speicherbereich aber noch immer aufwendig
- Besser ist, zwei Listen fuer belegten und freien Speicher, oder Baeume zu nutzen, oder die Eintraege nach Speichergroesse zu sortieren